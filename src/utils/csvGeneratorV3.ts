/**
 * CSV Generator V3 - Strict Google Ads Editor Format
 * 
 * This generator follows the exact Google Ads Editor CSV format specification
 * as defined in docs/CSV_GENERATOR_INSTRUCTIONS.md
 * 
 * Key Requirements:
 * - UTF-8 encoding with CRLF line endings (\r\n)
 * - Exact header names and order
 * - Proper field quoting
 * - Block-based structure
 * - Validation before export
 */

import { CampaignStructure, Campaign, AdGroup, Ad } from './campaignStructureGenerator';

// Block header definitions (exact as per specification)
const BLOCK_HEADERS = {
  CAMPAIGNS: '"Campaign","Campaign Status","Campaign Type","Networks","Daily Budget","Budget Type","Start Date","End Date","Bid Strategy Type","Campaign URL Options (Tracking Template)","Final URL Suffix","Campaign Language"',
  CAMPAIGN_SETTINGS: '"Campaign","Setting","Value"',
  SHARED_BUDGETS: '"Budget","Budget Amount","Delivery Method","Budget ID"',
  AD_GROUPS: '"Campaign","Ad Group","Ad Group Status","CPC Bid","Ad Group Default Max CPC","Ad Group Type"',
  KEYWORDS: '"Campaign","Ad Group","Keyword","Criterion Type","Final URL","Status","Custom Parameter"',
  CAMPAIGN_NEGATIVE_KEYWORDS: '"Campaign","Negative Keyword","Match Type"',
  AD_GROUP_NEGATIVE_KEYWORDS: '"Campaign","Ad Group","Negative Keyword","Match Type"',
  RSA_ADS: '"Campaign","Ad Group","Ad Type","Ad Status","Final URL","Headline 1","Headline 2","Headline 3","Headline 4","Headline 5","Description 1","Description 2","Path 1","Path 2","Ad Rotation"',
  ETA_ADS: '"Campaign","Ad Group","Ad Type","Ad Status","Final URL","Headline 1","Headline 2","Headline 3","Description 1","Description 2","Path 1","Path 2"',
  DSA_ADS: '"Campaign","Ad Group","Ad Type","Ad Status","Final URL","Domain","Language","Headline","Description"',
  IMAGE_ASSETS: '"Campaign","Ad Group","Ad Type","Ad Status","Image URL","Alt Text","Final URL"',
  SITELINK_EXTENSIONS: '"Campaign","Sitelink Text","Description Line 1","Description Line 2","Final URL","Device Preference","Start Date","End Date","Status"',
  CALLOUT_EXTENSIONS: '"Campaign","Callout Text","Start Date","End Date","Device Preference","Status"',
  STRUCTURED_SNIPPETS: '"Campaign","Header","Values","Start Date","End Date","Status"',
  CALL_EXTENSIONS: '"Campaign","Phone Number","Country Code","Phone Verification","Device Preference","Start Date","End Date","Status"',
  PRICE_EXTENSIONS: '"Campaign","Price Extension Type","Header","Price Qualifier","Price","Final URL","Currency","Start Date","End Date","Status"',
  APP_EXTENSIONS: '"Campaign","App Platform","App ID","Final URL","Start Date","End Date","Status"',
  LOCATION_TARGETING: '"Campaign","Location Target","Target Type","Bid Adjustment"',
  ZIP_TARGETING: '"Campaign","Location Target","Target Type","Bid Adjustment"',
  CITY_STATE_TARGETING: '"Campaign","Location Target","Target Type","Bid Adjustment"',
  AUDIENCE_TARGETING: '"Campaign","Ad Group","Audience Name","Audience Type","Bid Adjustment","Status"',
  AD_SCHEDULE: '"Campaign","Ad Schedule","Start Hour","End Hour","Start Minute","End Minute","Day of Week","Bid Modifier"',
  DEVICE_BID_ADJUSTMENT: '"Campaign","Device","Bid Adjustment"',
  LABELS: '"Campaign","Ad Group","Ad/Keyword/Asset","Label Name"',
  TRACKING_TEMPLATES: '"Campaign","Tracking Template","Final URL Suffix"',
  CUSTOM_PARAMETERS: '"Campaign","Ad Group","Param","Value"',
  UPLOAD_METADATA: '"Upload Notes","Generated By","Generation Timestamp"'
};

// Enum values (exact as per specification)
const ENUMS = {
  STATUS: ['Enabled', 'Paused', 'Removed'],
  CRITERION_TYPE: ['Broad', 'Phrase', 'Exact'],
  CAMPAIGN_TYPE: ['Search', 'Display', 'Shopping', 'Video', 'Smart', 'Performance Max'],
  AD_TYPE: ['Responsive search ad', 'Expanded text ad', 'Dynamic search ad'],
  MATCH_TYPE: ['Broad', 'Phrase', 'Exact', 'Broad (Negative)', 'Phrase (Negative)', 'Exact (Negative)']
};

export interface CSVValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

/**
 * Escape CSV field value
 * If field contains comma, quote it with double quotes
 * Escape double quotes as "" inside quoted fields
 */
function escapeCSVField(value: string | number | undefined | null): string {
  if (value === null || value === undefined) return '';
  
  const stringValue = String(value);
  
  // If value contains comma, quote, newline, or carriage return, wrap in quotes and escape quotes
  if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n') || stringValue.includes('\r')) {
    return `"${stringValue.replace(/"/g, '""')}"`;
  }
  
  return stringValue;
}

/**
 * Get match type from keyword format
 */
function getMatchType(keyword: string): string {
  const trimmed = keyword.trim();
  if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
    return 'Exact';
  } else if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
    return 'Phrase';
  } else if (trimmed.startsWith('-[') && trimmed.endsWith(']')) {
    return 'Exact (Negative)';
  } else if (trimmed.startsWith('-"') && trimmed.endsWith('"')) {
    return 'Phrase (Negative)';
  } else if (trimmed.startsWith('-')) {
    return 'Broad (Negative)';
  }
  return 'Broad';
}

/**
 * Clean keyword text (remove brackets/quotes for display)
 */
function cleanKeywordText(keyword: string): string {
  return keyword.replace(/^\[|\]$|^"|"$|^-\[|-\]$|^-"|-"$|^-/g, '').trim();
}

/**
 * Validate date format (YYYY-MM-DD)
 */
function isValidDate(date: string): boolean {
  if (!date || date.trim() === '') return true; // Empty dates are allowed
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(date)) return false;
  const d = new Date(date);
  return d instanceof Date && !isNaN(d.getTime());
}

/**
 * Validate campaign structure before generating CSV
 */
export function validateCampaignStructure(structure: CampaignStructure): CSVValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  
  if (!structure || !structure.campaigns || structure.campaigns.length === 0) {
    errors.push('Campaign structure is empty or invalid');
    return { isValid: false, errors, warnings };
  }
  
  const campaignNames = new Set<string>();
  const adGroupMap = new Map<string, Set<string>>(); // campaign -> ad groups
  
  structure.campaigns.forEach((campaign, campaignIdx) => {
    // Validate campaign name
    if (!campaign.campaign_name || campaign.campaign_name.trim() === '') {
      errors.push(`Campaign ${campaignIdx + 1}: Campaign name is required`);
    } else {
      campaignNames.add(campaign.campaign_name);
    }
    
    // Validate ad groups
    if (!campaign.adgroups || campaign.adgroups.length === 0) {
      warnings.push(`Campaign "${campaign.campaign_name}": No ad groups found`);
    } else {
      const adGroups = new Set<string>();
      campaign.adgroups.forEach((adGroup, adGroupIdx) => {
        if (!adGroup.adgroup_name || adGroup.adgroup_name.trim() === '') {
          errors.push(`Campaign "${campaign.campaign_name}", Ad Group ${adGroupIdx + 1}: Ad group name is required`);
        } else {
          adGroups.add(adGroup.adgroup_name);
        }
        
        // Validate keywords
        if (!adGroup.keywords || adGroup.keywords.length === 0) {
          warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}": No keywords found`);
        }
        
        // Validate ads
        if (!adGroup.ads || adGroup.ads.length === 0) {
          warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}": No ads found`);
        } else {
          adGroup.ads.forEach((ad, adIdx) => {
            if (!ad.final_url || ad.final_url.trim() === '') {
              errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Final URL is required`);
            } else if (!ad.final_url.match(/^https?:\/\//i)) {
              errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Final URL must start with http:// or https://`);
            }
            
            if (ad.type === 'rsa' || ad.type === 'dki') {
              // Validate headlines - at least 3 required for RSA
              const headlines = [ad.headline1, ad.headline2, ad.headline3].filter(h => h && h.trim());
              if (headlines.length < 3) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: RSA/DKI ads require at least 3 headlines (currently has ${headlines.length})`);
              }
              
              // Validate individual headlines
              if (!ad.headline1 || ad.headline1.trim() === '') {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Headline 1 is required for RSA/DKI ads`);
              } else if (ad.headline1.length > 30) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Headline 1 exceeds 30 characters (${ad.headline1.length} chars)`);
              }
              
              if (ad.headline2 && ad.headline2.length > 30) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Headline 2 exceeds 30 characters (${ad.headline2.length} chars)`);
              }
              
              if (ad.headline3 && ad.headline3.length > 30) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Headline 3 exceeds 30 characters (${ad.headline3.length} chars)`);
              }
              
              // Validate descriptions - at least 2 required for RSA
              const descriptions = [ad.description1, ad.description2].filter(d => d && d.trim());
              if (descriptions.length < 2) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: RSA/DKI ads require at least 2 descriptions (currently has ${descriptions.length})`);
              }
              
              if (!ad.description1 || ad.description1.trim() === '') {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Description 1 is required for RSA/DKI ads`);
              } else if (ad.description1.length > 90) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Description 1 exceeds 90 characters (${ad.description1.length} chars)`);
              }
              
              if (ad.description2 && ad.description2.length > 90) {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Description 2 exceeds 90 characters (${ad.description2.length} chars)`);
              }
            }
            
            if (ad.type === 'callonly') {
              // Call-only ads need headline1, headline2, description1, description2, and phone
              if (!ad.headline1 || ad.headline1.trim() === '') {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Headline 1 is required for Call-Only ads`);
              }
              if (!ad.headline2 || ad.headline2.trim() === '') {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Headline 2 is required for Call-Only ads`);
              }
              if (!ad.description1 || ad.description1.trim() === '') {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Description 1 is required for Call-Only ads`);
              }
              if (!ad.description2 || ad.description2.trim() === '') {
                errors.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}: Description 2 is required for Call-Only ads`);
              }
            }
            
            // Validate extensions/assets if present
            if (ad.extensions && Array.isArray(ad.extensions) && ad.extensions.length > 0) {
              ad.extensions.forEach((ext: any, extIdx: number) => {
                const extType = ext.extensionType || ext.type;
                
                if (extType === 'sitelink') {
                  const links = ext.links || ext.sitelinks || [];
                  if (links.length === 0) {
                    warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}, Extension ${extIdx + 1}: Sitelink extension missing link data`);
                  }
                } else if (extType === 'callout') {
                  const callouts = ext.callouts || ext.values || [];
                  if (callouts.length === 0 || !callouts[0] || callouts[0].trim() === '') {
                    warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}, Extension ${extIdx + 1}: Callout extension missing text`);
                  }
                } else if (extType === 'snippet') {
                  if (!ext.header || ext.header.trim() === '') {
                    warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}, Extension ${extIdx + 1}: Structured snippet extension missing header`);
                  }
                  const values = ext.values || [];
                  if (values.length === 0 || !values[0] || values[0].trim() === '') {
                    warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}, Extension ${extIdx + 1}: Structured snippet extension missing values`);
                  }
                } else if (extType === 'call') {
                  if (!ext.phone && !ext.phoneNumber || (ext.phone || ext.phoneNumber || '').trim() === '') {
                    warnings.push(`Campaign "${campaign.campaign_name}", Ad Group "${adGroup.adgroup_name}", Ad ${adIdx + 1}, Extension ${extIdx + 1}: Call extension missing phone number`);
                  }
                }
              });
            }
          });
        }
      });
      adGroupMap.set(campaign.campaign_name, adGroups);
    }
  });
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
}

/**
 * Generate CSV content from campaign structure
 * Follows exact Google Ads Editor format specification
 */
export function generateCSVV3(structure: CampaignStructure): string {
  // Validate structure first
  const validation = validateCampaignStructure(structure);
  if (!validation.isValid) {
    const errorMessage = validation.errors.length > 0 
      ? validation.errors.join('\n')
      : 'Unknown validation error';
    throw new Error(`CSV validation failed:\n${errorMessage}`);
  }
  
  // Additional safety check
  if (!structure || !structure.campaigns || structure.campaigns.length === 0) {
    throw new Error('Campaign structure is empty. Please ensure you have at least one campaign with ad groups and ads.');
  }
  
  const blocks: string[] = [];
  
  // 1. Campaigns Block
  blocks.push(BLOCK_HEADERS.CAMPAIGNS);
  structure.campaigns.forEach(campaign => {
    const row = [
      escapeCSVField(campaign.campaign_name),
      escapeCSVField('Enabled'), // Campaign Status
      escapeCSVField('Search'), // Campaign Type
      escapeCSVField('Search Network'), // Networks
      escapeCSVField(''), // Daily Budget
      escapeCSVField(''), // Budget Type
      escapeCSVField(''), // Start Date
      escapeCSVField(''), // End Date
      escapeCSVField(''), // Bid Strategy Type
      escapeCSVField(''), // Tracking Template
      escapeCSVField(''), // Final URL Suffix
      escapeCSVField('en') // Campaign Language
    ];
    blocks.push(row.join(','));
  });
  blocks.push(''); // Blank line between blocks
  
  // 2. Campaign Settings Block (optional - can be empty)
  blocks.push(BLOCK_HEADERS.CAMPAIGN_SETTINGS);
  blocks.push(''); // Blank line between blocks
  
  // 3. Shared Budgets Block (optional - can be empty)
  blocks.push(BLOCK_HEADERS.SHARED_BUDGETS);
  blocks.push(''); // Blank line between blocks
  
  // 4. Ad Groups Block
  blocks.push(BLOCK_HEADERS.AD_GROUPS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      const row = [
        escapeCSVField(campaign.campaign_name),
        escapeCSVField(adGroup.adgroup_name),
        escapeCSVField('Enabled'), // Ad Group Status
        escapeCSVField(''), // CPC Bid
        escapeCSVField(''), // Ad Group Default Max CPC
        escapeCSVField('') // Ad Group Type
      ];
      blocks.push(row.join(','));
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 5. Keywords Block
  blocks.push(BLOCK_HEADERS.KEYWORDS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      adGroup.keywords.forEach(keyword => {
        const matchType = getMatchType(keyword);
        const cleanKeyword = cleanKeywordText(keyword);
        const defaultUrl = adGroup.ads && adGroup.ads.length > 0 
          ? (adGroup.ads[0].final_url || 'https://www.example.com')
          : 'https://www.example.com';
        
        const row = [
          escapeCSVField(campaign.campaign_name),
          escapeCSVField(adGroup.adgroup_name),
          escapeCSVField(cleanKeyword),
          escapeCSVField(matchType),
          escapeCSVField(defaultUrl),
          escapeCSVField('Enabled'),
          escapeCSVField('') // Custom Parameter
        ];
        blocks.push(row.join(','));
      });
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 6. Campaign Negative Keywords Block
  blocks.push(BLOCK_HEADERS.CAMPAIGN_NEGATIVE_KEYWORDS);
  // Collect campaign-level negative keywords if any
  structure.campaigns.forEach(campaign => {
    // Check if campaign has negative keywords (would need to be added to structure)
    // For now, skip if not present
  });
  blocks.push(''); // Blank line between blocks
  
  // 7. Ad Group Negative Keywords Block
  blocks.push(BLOCK_HEADERS.AD_GROUP_NEGATIVE_KEYWORDS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      if (adGroup.negative_keywords && adGroup.negative_keywords.length > 0) {
        adGroup.negative_keywords.forEach(negativeKw => {
          const matchType = getMatchType(negativeKw);
          const cleanNegative = cleanKeywordText(negativeKw);
          const row = [
            escapeCSVField(campaign.campaign_name),
            escapeCSVField(adGroup.adgroup_name),
            escapeCSVField(cleanNegative),
            escapeCSVField(matchType)
          ];
          blocks.push(row.join(','));
        });
      }
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 8. RSA Ads Block
  blocks.push(BLOCK_HEADERS.RSA_ADS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      adGroup.ads.forEach(ad => {
        if (ad.type === 'rsa' || ad.type === 'dki') {
          const row = [
            escapeCSVField(campaign.campaign_name),
            escapeCSVField(adGroup.adgroup_name),
            escapeCSVField('Responsive search ad'),
            escapeCSVField('Enabled'),
            escapeCSVField(ad.final_url || 'https://www.example.com'),
            escapeCSVField(ad.headline1 || ''),
            escapeCSVField(ad.headline2 || ''),
            escapeCSVField(ad.headline3 || ''),
            escapeCSVField(ad.headline4 || ''),
            escapeCSVField(ad.headline5 || ''),
            escapeCSVField(ad.description1 || ''),
            escapeCSVField(ad.description2 || ''),
            escapeCSVField(ad.path1 || ''),
            escapeCSVField(ad.path2 || ''),
            escapeCSVField('') // Ad Rotation
          ];
          blocks.push(row.join(','));
        }
      });
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 9. ETA Ads Block (if any)
  blocks.push(BLOCK_HEADERS.ETA_ADS);
  // ETA ads would go here if we have any
  blocks.push(''); // Blank line between blocks
  
  // 10. DSA Ads Block (if any)
  blocks.push(BLOCK_HEADERS.DSA_ADS);
  // DSA ads would go here if we have any
  blocks.push(''); // Blank line between blocks
  
  // 11. Image Assets Block (if any)
  blocks.push(BLOCK_HEADERS.IMAGE_ASSETS);
  // Image assets would go here if we have any
  blocks.push(''); // Blank line between blocks
  
  // 12. Sitelink Extensions Block
  blocks.push(BLOCK_HEADERS.SITELINK_EXTENSIONS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      adGroup.ads.forEach(ad => {
        if (ad.extensions && Array.isArray(ad.extensions)) {
          ad.extensions.forEach((ext: any) => {
            if (ext.extensionType === 'sitelink' || ext.type === 'sitelink') {
              const links = ext.links || ext.sitelinks || [];
              links.forEach((link: any) => {
                const row = [
                  escapeCSVField(campaign.campaign_name),
                  escapeCSVField(link.text || link.linkText || ''),
                  escapeCSVField(link.description || link.descriptionLine1 || ''),
                  escapeCSVField(link.descriptionLine2 || ''),
                  escapeCSVField(link.url || link.finalUrl || ad.final_url || ''),
                  escapeCSVField(''), // Device Preference
                  escapeCSVField(''), // Start Date
                  escapeCSVField(''), // End Date
                  escapeCSVField('Enabled')
                ];
                blocks.push(row.join(','));
              });
            }
          });
        }
      });
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 13. Callout Extensions Block
  blocks.push(BLOCK_HEADERS.CALLOUT_EXTENSIONS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      adGroup.ads.forEach(ad => {
        if (ad.extensions && Array.isArray(ad.extensions)) {
          ad.extensions.forEach((ext: any) => {
            if (ext.extensionType === 'callout' || ext.type === 'callout') {
              const callouts = ext.callouts || ext.values || [];
              callouts.forEach((callout: string) => {
                const row = [
                  escapeCSVField(campaign.campaign_name),
                  escapeCSVField(callout),
                  escapeCSVField(''), // Start Date
                  escapeCSVField(''), // End Date
                  escapeCSVField(''), // Device Preference
                  escapeCSVField('Enabled')
                ];
                blocks.push(row.join(','));
              });
            }
          });
        }
      });
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 14. Structured Snippets Block
  blocks.push(BLOCK_HEADERS.STRUCTURED_SNIPPETS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      adGroup.ads.forEach(ad => {
        if (ad.extensions && Array.isArray(ad.extensions)) {
          ad.extensions.forEach((ext: any) => {
            if (ext.extensionType === 'snippet' || ext.type === 'snippet') {
              const values = ext.values || [];
              values.forEach((value: string) => {
                const row = [
                  escapeCSVField(campaign.campaign_name),
                  escapeCSVField(ext.header || ext.title || ''),
                  escapeCSVField(value),
                  escapeCSVField(''), // Start Date
                  escapeCSVField(''), // End Date
                  escapeCSVField('Enabled')
                ];
                blocks.push(row.join(','));
              });
            }
          });
        }
      });
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 15. Call Extensions Block
  blocks.push(BLOCK_HEADERS.CALL_EXTENSIONS);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      adGroup.ads.forEach(ad => {
        if (ad.extensions && Array.isArray(ad.extensions)) {
          ad.extensions.forEach((ext: any) => {
            if (ext.extensionType === 'call' || ext.type === 'call') {
              const row = [
                escapeCSVField(campaign.campaign_name),
                escapeCSVField(ext.phone || ext.phoneNumber || ''),
                escapeCSVField(ext.countryCode || ext.country || 'US'),
                escapeCSVField(''), // Phone Verification
                escapeCSVField(''), // Device Preference
                escapeCSVField(''), // Start Date
                escapeCSVField(''), // End Date
                escapeCSVField('Enabled')
              ];
              blocks.push(row.join(','));
            }
          });
        }
      });
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 16-22. Other extension blocks (Price, App, etc.) - can be empty
  blocks.push(BLOCK_HEADERS.PRICE_EXTENSIONS);
  blocks.push('');
  blocks.push(BLOCK_HEADERS.APP_EXTENSIONS);
  blocks.push('');
  
  // 23. Location Targeting Block
  blocks.push(BLOCK_HEADERS.LOCATION_TARGETING);
  structure.campaigns.forEach(campaign => {
    campaign.adgroups.forEach(adGroup => {
      if (adGroup.location_target) {
        const locations = adGroup.location_target.split(',').map(l => l.trim()).filter(l => l.length > 0);
        locations.forEach(location => {
          const row = [
            escapeCSVField(campaign.campaign_name),
            escapeCSVField(location),
            escapeCSVField('Location of interest'), // Target Type
            escapeCSVField('') // Bid Adjustment
          ];
          blocks.push(row.join(','));
        });
      }
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 24. ZIP/Postal Code Targeting Block
  blocks.push(BLOCK_HEADERS.ZIP_TARGETING);
  structure.campaigns.forEach(campaign => {
    // Check campaign-level zip codes
    if (campaign.zip_codes && campaign.zip_codes.length > 0) {
      campaign.zip_codes.forEach(zip => {
        const row = [
          escapeCSVField(campaign.campaign_name),
          escapeCSVField(zip),
          escapeCSVField('Postal Code'), // Target Type
          escapeCSVField('') // Bid Adjustment
        ];
        blocks.push(row.join(','));
      });
    }
    // Check ad group-level zip codes
    campaign.adgroups.forEach(adGroup => {
      if (adGroup.zip_codes && adGroup.zip_codes.length > 0) {
        adGroup.zip_codes.forEach(zip => {
          const row = [
            escapeCSVField(campaign.campaign_name),
            escapeCSVField(zip),
            escapeCSVField('Postal Code'), // Target Type
            escapeCSVField('') // Bid Adjustment
          ];
          blocks.push(row.join(','));
        });
      }
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 25. City/State Targeting Block
  blocks.push(BLOCK_HEADERS.CITY_STATE_TARGETING);
  structure.campaigns.forEach(campaign => {
    // Check campaign-level cities
    if (campaign.cities && campaign.cities.length > 0) {
      campaign.cities.forEach(city => {
        const row = [
          escapeCSVField(campaign.campaign_name),
          escapeCSVField(city),
          escapeCSVField('City'), // Target Type
          escapeCSVField('') // Bid Adjustment
        ];
        blocks.push(row.join(','));
      });
    }
    // Check campaign-level states
    if (campaign.states && campaign.states.length > 0) {
      campaign.states.forEach(state => {
        const row = [
          escapeCSVField(campaign.campaign_name),
          escapeCSVField(state),
          escapeCSVField('State'), // Target Type
          escapeCSVField('') // Bid Adjustment
        ];
        blocks.push(row.join(','));
      });
    }
    // Check ad group-level cities
    campaign.adgroups.forEach(adGroup => {
      if (adGroup.cities && adGroup.cities.length > 0) {
        adGroup.cities.forEach(city => {
          const row = [
            escapeCSVField(campaign.campaign_name),
            escapeCSVField(city),
            escapeCSVField('City'), // Target Type
            escapeCSVField('') // Bid Adjustment
          ];
          blocks.push(row.join(','));
        });
      }
      // Check ad group-level states
      if (adGroup.states && adGroup.states.length > 0) {
        adGroup.states.forEach(state => {
          const row = [
            escapeCSVField(campaign.campaign_name),
            escapeCSVField(state),
            escapeCSVField('State'), // Target Type
            escapeCSVField('') // Bid Adjustment
          ];
          blocks.push(row.join(','));
        });
      }
    });
  });
  blocks.push(''); // Blank line between blocks
  
  // 26-32. Other targeting and adjustment blocks (can be empty)
  blocks.push(BLOCK_HEADERS.AUDIENCE_TARGETING);
  blocks.push('');
  blocks.push(BLOCK_HEADERS.AD_SCHEDULE);
  blocks.push('');
  blocks.push(BLOCK_HEADERS.DEVICE_BID_ADJUSTMENT);
  blocks.push('');
  blocks.push(BLOCK_HEADERS.LABELS);
  blocks.push('');
  blocks.push(BLOCK_HEADERS.TRACKING_TEMPLATES);
  blocks.push('');
  blocks.push(BLOCK_HEADERS.CUSTOM_PARAMETERS);
  blocks.push('');
  
  // 33. Upload Metadata Block (required)
  blocks.push(BLOCK_HEADERS.UPLOAD_METADATA);
  const metadataRow = [
    escapeCSVField('Generated by Adiology Campaign Dashboard'),
    escapeCSVField('CSV Generator V3'),
    escapeCSVField(new Date().toISOString())
  ];
  blocks.push(metadataRow.join(','));
  
  // Join all blocks with CRLF line endings (\r\n)
  return blocks.join('\r\n');
}

/**
 * Export campaign structure to CSV file using V3 format
 */
export function exportCampaignToCSVV3(
  structure: CampaignStructure,
  filename: string = 'campaign_export.csv'
): void {
  try {
    // Generate CSV content
    const csvContent = generateCSVV3(structure);
    
    // Create blob with UTF-8 encoding
    // Note: BOM is not needed for Google Ads Editor
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    
    link.setAttribute('href', url);
    link.setAttribute('download', filename);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  } catch (error) {
    console.error('CSV export error:', error);
    throw error;
  }
}

/**
 * Validate CSV content before export
 * This is a pre-export validation function
 */
export function validateCSVBeforeExport(structure: CampaignStructure): CSVValidationResult {
  return validateCampaignStructure(structure);
}

/**
 * Convert preset data to CampaignStructure format
 * Helper function for converting presets to V3 format
 */
export function presetToCampaignStructure(preset: any): CampaignStructure {
  // Clean and validate final URL
  let finalUrl = preset.final_url || preset.landing_page_url || 'https://www.example.com';
  if (!finalUrl.match(/^https?:\/\//i)) {
    finalUrl = 'https://' + finalUrl;
  }
  
  // Clean keywords (remove existing brackets/quotes)
  const cleanKeywords = (preset.keywords || []).map((kw: string) => {
    return cleanKeywordText(kw);
  });
  
  // Determine match type distribution
  const hasExact = preset.match_distribution?.exact > 0;
  const hasPhrase = preset.match_distribution?.phrase > 0;
  const hasBroad = preset.match_distribution?.broad_mod > 0;
  
  // Structure determines keyword distribution
  const structure = preset.structure || 'SKAG';
  const isSKAG = structure === 'SKAG';
  
  const adGroups: AdGroup[] = preset.ad_groups.map((adGroup: any, adGroupIdx: number) => {
    // Distribute keywords based on structure
    let groupKeywords: string[] = [];
    
    if (isSKAG) {
      // SKAG: One keyword per ad group (use ad group name as keyword if available, otherwise distribute)
      const keywordIndex = adGroupIdx < cleanKeywords.length ? adGroupIdx : adGroupIdx % cleanKeywords.length;
      const baseKeyword = cleanKeywords[keywordIndex] || adGroup.name || 'keyword';
      
      // Apply match types to this single keyword
      if (hasExact) groupKeywords.push(`[${baseKeyword}]`);
      if (hasPhrase) groupKeywords.push(`"${baseKeyword}"`);
      if (hasBroad) groupKeywords.push(baseKeyword);
    } else {
      // STAG/Other: Distribute keywords across ad groups
      const keywordsPerGroup = Math.ceil(cleanKeywords.length / preset.ad_groups.length);
      const startIdx = adGroupIdx * keywordsPerGroup;
      const endIdx = Math.min(startIdx + keywordsPerGroup, cleanKeywords.length);
      const assignedKeywords = cleanKeywords.slice(startIdx, endIdx);
      
      // Apply match types to each keyword
      assignedKeywords.forEach((keyword: string) => {
        if (hasExact) groupKeywords.push(`[${keyword}]`);
        if (hasPhrase) groupKeywords.push(`"${keyword}"`);
        if (hasBroad) groupKeywords.push(keyword);
      });
    }
    
    // Convert ads - ensure all required fields are present
    const ads: Ad[] = (preset.ads || []).map((ad: any) => {
      // Ensure headline1 and description1 are present (required for RSA)
      const headline1 = (ad.headline1 || preset.ads?.[0]?.headline1 || 'Your Service Here').trim();
      const description1 = (ad.description1 || preset.ads?.[0]?.description1 || 'Get the best service today.').trim();
      
      // Validate headline and description lengths
      const validatedHeadline1 = headline1.length > 30 ? headline1.substring(0, 30) : headline1;
      const validatedDescription1 = description1.length > 90 ? description1.substring(0, 90) : description1;
      
      return {
        type: 'rsa' as const,
        headline1: validatedHeadline1 || 'Your Service Here',
        headline2: (ad.headline2 || preset.ads?.[0]?.headline2 || '').trim(),
        headline3: (ad.headline3 || preset.ads?.[0]?.headline3 || '').trim(),
        headline4: (ad.headline4 || preset.ads?.[0]?.headline4 || '').trim(),
        headline5: (ad.headline5 || preset.ads?.[0]?.headline5 || '').trim(),
        description1: validatedDescription1 || 'Get the best service today.',
        description2: (ad.description2 || preset.ads?.[0]?.description2 || '').trim(),
        final_url: finalUrl,
        path1: (ad.path1 || '').trim(),
        path2: (ad.path2 || '').trim()
      };
    });
    
    // Ensure at least one ad exists
    if (ads.length === 0) {
      ads.push({
        type: 'rsa' as const,
        headline1: 'Your Service Here',
        headline2: '',
        headline3: '',
        headline4: '',
        headline5: '',
        description1: 'Get the best service today.',
        description2: '',
        final_url: finalUrl,
        path1: '',
        path2: ''
      });
    }
    
    // Convert negative keywords - ensure proper formatting
    const negative_keywords = (preset.negative_keywords || []).map((negKw: string) => {
      const clean = cleanKeywordText(negKw);
      // Add negative prefix if not present
      if (!clean.startsWith('-')) {
        return `-${clean}`;
      }
      return clean;
    });
    
    return {
      adgroup_name: adGroup.name || `Ad Group ${adGroupIdx + 1}`,
      keywords: groupKeywords,
      match_types: [],
      ads,
      negative_keywords
    };
  });
  
  // Ensure campaign name is present
  const campaignName = (preset.campaign_name || preset.title || 'Campaign').trim();
  
  return {
    campaigns: [{
      campaign_name: campaignName,
      adgroups: adGroups
    }]
  };
}

/**
 * Convert keywords-only data to CampaignStructure format
 * For simple keyword exports (e.g., Keywords Builder)
 */
export function keywordsToCampaignStructure(
  keywords: string[],
  campaignName: string = 'Keywords Campaign',
  adGroupName: string = 'All Keywords',
  finalUrl: string = 'https://www.example.com'
): CampaignStructure {
  return {
    campaigns: [{
      campaign_name: campaignName,
      adgroups: [{
        adgroup_name: adGroupName,
        keywords: keywords,
        match_types: [],
        ads: [{
          type: 'rsa',
          headline1: 'Your Service Here',
          description1: 'Get the best service today.',
          final_url: finalUrl
        }],
        negative_keywords: []
      }]
    }]
  };
}

/**
 * Convert negative keywords-only data to CampaignStructure format
 * For negative keyword exports
 */
export function negativeKeywordsToCampaignStructure(
  negativeKeywords: string[],
  campaignName: string = 'Negative Keywords Campaign',
  adGroupName: string = 'All Ad Groups',
  finalUrl: string = 'https://www.example.com'
): CampaignStructure {
  return {
    campaigns: [{
      campaign_name: campaignName,
      adgroups: [{
        adgroup_name: adGroupName,
        keywords: [], // No positive keywords for negative-only export
        match_types: [],
        ads: [{
          type: 'rsa',
          headline1: 'Your Service Here',
          description1: 'Get the best service today.',
          final_url: finalUrl
        }],
        negative_keywords: negativeKeywords
      }]
    }]
  };
}

/**
 * Convert ads-only data to CampaignStructure format
 * For Ads Builder exports
 */
export function adsToCampaignStructure(
  ads: any[],
  campaignName: string = 'Ads Campaign',
  finalUrl: string = 'https://www.example.com'
): CampaignStructure {
  // Helper function to ensure URL is valid
  const ensureValidUrl = (url: string | undefined | null): string => {
    if (!url || url.trim() === '') {
      return finalUrl || 'https://www.example.com';
    }
    const trimmed = url.trim();
    // If URL doesn't start with http:// or https://, add https://
    if (!trimmed.match(/^https?:\/\//i)) {
      return `https://${trimmed}`;
    }
    return trimmed;
  };
  
  // Group ads by ad group
  const adGroupsMap = new Map<string, any[]>();
  ads.forEach(ad => {
    const groupName = ad.groupName || ad.adGroup || 'All Ads';
    if (!adGroupsMap.has(groupName)) {
      adGroupsMap.set(groupName, []);
    }
    adGroupsMap.get(groupName)!.push(ad);
  });
  
  const adGroups: AdGroup[] = Array.from(adGroupsMap.entries()).map(([groupName, groupAds]) => {
    // Collect location data from first ad in group (if available)
    const firstAd = groupAds[0];
    const locationTarget = firstAd?.location_target || firstAd?.locationTarget;
    const zipCodes = firstAd?.zip_codes || firstAd?.zipCodes || [];
    const cities = firstAd?.cities || [];
    const states = firstAd?.states || [];
    
    const convertedAds: Ad[] = groupAds.map(ad => {
      // Ensure required fields are present and valid
      // Convert Call-Only ads to RSA format for CSV export (Google Ads Editor doesn't support Call-Only in CSV)
      const adType = (ad.adType === 'CallOnly' ? 'rsa' : ad.adType === 'DKI' ? 'dki' : 'rsa') as 'rsa' | 'dki' | 'callonly';
      
      // For RSA/DKI, ensure we have at least 3 headlines and 2 descriptions
      let headline1 = (ad.headline1 || '').trim();
      let headline2 = (ad.headline2 || '').trim();
      let headline3 = (ad.headline3 || '').trim();
      
      // If missing headlines, use fallbacks
      if (!headline1) headline1 = 'Professional Service';
      if (!headline2) headline2 = 'Expert Solutions';
      if (!headline3) headline3 = 'Quality Guaranteed';
      
      let description1 = (ad.description1 || '').trim();
      let description2 = (ad.description2 || '').trim();
      
      // If missing descriptions, use fallbacks
      if (!description1) description1 = 'Get professional service you can trust.';
      if (!description2) description2 = 'Contact us today for expert assistance.';
      
      // Truncate if too long (Google Ads limits)
      headline1 = headline1.length > 30 ? headline1.substring(0, 30) : headline1;
      headline2 = headline2.length > 30 ? headline2.substring(0, 30) : headline2;
      headline3 = headline3.length > 30 ? headline3.substring(0, 30) : headline3;
      description1 = description1.length > 90 ? description1.substring(0, 90) : description1;
      description2 = description2.length > 90 ? description2.substring(0, 90) : description2;
      
      // Ensure final URL is valid
      const validFinalUrl = ensureValidUrl(ad.finalUrl || finalUrl);
      
      // Ensure path1 and path2 are within limits (15 chars each)
      const path1 = (ad.path1 || '').trim().substring(0, 15);
      const path2 = (ad.path2 || '').trim().substring(0, 15);
      
      // Preserve extensions if they exist
      const extensions = ad.extensions && Array.isArray(ad.extensions) ? ad.extensions : [];
      
      return {
        type: adType,
        headline1,
        headline2,
        headline3,
        headline4: (ad.headline4 || '').trim().substring(0, 30),
        headline5: (ad.headline5 || '').trim().substring(0, 30),
        description1,
        description2,
        final_url: validFinalUrl,
        path1,
        path2,
        extensions: extensions // Preserve extensions
      };
    });
    
    return {
      adgroup_name: groupName,
      keywords: [], // Ads-only export has no keywords
      match_types: [],
      ads: convertedAds,
      negative_keywords: [],
      // Preserve location data
      location_target: locationTarget,
      zip_codes: zipCodes.length > 0 ? zipCodes : undefined,
      cities: cities.length > 0 ? cities : undefined,
      states: states.length > 0 ? states : undefined
    };
  });
  
  return {
    campaigns: [{
      campaign_name: campaignName,
      adgroups: adGroups
    }]
  };
}

/**
 * Unified export function with validation
 * Use this for all CSV exports across the platform
 */
export async function exportCSVWithValidation(
  data: CampaignStructure | any,
  filename: string,
  dataType: 'structure' | 'preset' | 'keywords' | 'negativeKeywords' | 'ads' = 'structure',
  options?: {
    campaignName?: string;
    adGroupName?: string;
    finalUrl?: string;
  }
): Promise<{ isValid: boolean; errors?: string[]; warnings?: string[]; structure?: CampaignStructure }> {
  let structure: CampaignStructure;
  
  // Convert data to CampaignStructure format based on type
  switch (dataType) {
    case 'structure':
      structure = data as CampaignStructure;
      break;
    case 'preset':
      structure = presetToCampaignStructure(data);
      break;
    case 'keywords':
      structure = keywordsToCampaignStructure(
        data,
        options?.campaignName,
        options?.adGroupName,
        options?.finalUrl
      );
      break;
    case 'negativeKeywords':
      structure = negativeKeywordsToCampaignStructure(
        data,
        options?.campaignName,
        options?.adGroupName,
        options?.finalUrl
      );
      break;
    case 'ads':
      structure = adsToCampaignStructure(
        data,
        options?.campaignName,
        options?.finalUrl
      );
      break;
    default:
      throw new Error(`Unknown data type: ${dataType}`);
  }
  
  // Validate before export
  const validation = validateCSVBeforeExport(structure);
  
  // Return validation results - let the caller decide whether to proceed
  // The caller should check validation.isValid before calling exportCampaignToCSVV3
  return {
    isValid: validation.isValid,
    errors: validation.errors,
    warnings: validation.warnings,
    structure: structure
  };
}

